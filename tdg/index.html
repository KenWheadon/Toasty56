<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Enhanced Tower Defense</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background: linear-gradient(135deg, #1e293b, #334155);
        color: white;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .game-container {
        max-width: 1200px;
        width: 100%;
      }

      h1 {
        text-align: center;
        color: #22d3ee;
        margin-bottom: 20px;
        font-size: 2.5em;
      }

      .menu-screen {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 80vh;
      }

      .menu-content {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 30px;
        margin-bottom: 40px;
        max-width: 800px;
      }

      .info-panel {
        background: #374151;
        padding: 20px;
        border-radius: 10px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .info-panel h2 {
        color: #fbbf24;
        margin-bottom: 15px;
      }

      .info-panel h3 {
        color: #22d3ee;
        margin-bottom: 15px;
      }

      .tower-info {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 8px;
      }

      .start-btn {
        background: linear-gradient(45deg, #059669, #2563eb);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 1.2em;
        font-weight: bold;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
      }

      .start-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      }

      .game-screen {
        display: none;
        flex-direction: column;
        align-items: center;
      }

      .tutorial {
        background: linear-gradient(45deg, #d97706, #ea580c);
        color: white;
        padding: 15px 30px;
        border-radius: 10px;
        margin-bottom: 15px;
        font-weight: bold;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .effects {
        background: #059669;
        color: white;
        padding: 10px 20px;
        border-radius: 10px;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
        gap: 10px;
        margin-bottom: 15px;
        max-width: 600px;
      }

      .stat-item {
        padding: 10px 15px;
        border-radius: 8px;
        font-weight: bold;
        text-align: center;
        font-size: 0.9em;
      }

      .coins {
        background: #d97706;
      }
      .lives {
        background: #dc2626;
      }
      .wave {
        background: #2563eb;
      }
      .score {
        background: #7c3aed;
      }
      .level {
        background: #059669;
      }
      .skill-points {
        background: #0891b2;
      }

      .exp-bar {
        width: 100%;
        max-width: 400px;
        margin-bottom: 10px;
      }

      .exp-bar-container {
        background: #374151;
        border-radius: 10px;
        height: 8px;
        overflow: hidden;
      }

      .exp-bar-fill {
        background: linear-gradient(45deg, #059669, #2563eb);
        height: 100%;
        transition: width 0.3s;
      }

      .exp-text {
        text-align: center;
        font-size: 0.8em;
        margin-top: 5px;
      }

      .kill-streak {
        background: linear-gradient(45deg, #dc2626, #ea580c);
        padding: 10px 20px;
        border-radius: 10px;
        font-weight: bold;
        margin-bottom: 10px;
      }

      .wave-progress {
        width: 100%;
        max-width: 400px;
        margin-bottom: 20px;
      }

      .wave-progress-container {
        background: #374151;
        border-radius: 10px;
        height: 16px;
        overflow: hidden;
      }

      .wave-progress-fill {
        background: linear-gradient(45deg, #2563eb, #22d3ee);
        height: 100%;
        transition: width 0.3s;
      }

      .wave-text {
        text-align: center;
        font-size: 0.9em;
        margin-top: 5px;
      }

      .next-wave-preview {
        background: #374151;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        text-align: center;
      }

      .enemy-preview {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 5px;
        margin-top: 10px;
      }

      .abilities {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .ability-btn {
        background: linear-gradient(45deg, #7c3aed, #ec4899);
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
      }

      .ability-btn:disabled {
        background: #6b7280;
        cursor: not-allowed;
      }

      .ability-btn:hover:not(:disabled) {
        transform: scale(1.05);
      }

      .game-area {
        background: linear-gradient(45deg, #166534, #15803d);
        border: 4px solid #475569;
        border-radius: 10px;
        position: relative;
        cursor: default;
      }

      .game-area.placing {
        cursor: crosshair;
      }

      .tower-buttons {
        display: flex;
        gap: 10px;
        margin-top: 20px;
        flex-wrap: wrap;
        justify-content: center;
      }

      .tower-btn {
        background: #059669;
        color: white;
        border: none;
        padding: 10px 15px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tower-btn:disabled {
        background: #6b7280;
        cursor: not-allowed;
      }

      .tower-btn.selected {
        background: #2563eb;
      }

      .tower-btn:hover:not(:disabled) {
        background: #047857;
      }

      .tower-info-panel {
        background: #374151;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
        text-align: center;
      }

      .tower-stats {
        display: flex;
        gap: 20px;
        justify-content: center;
        margin: 15px 0;
      }

      .upgrade-btn {
        background: #2563eb;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
      }

      .upgrade-btn:disabled {
        background: #6b7280;
        cursor: not-allowed;
      }

      .upgrade-btn:hover:not(:disabled) {
        background: #1d4ed8;
      }

      .skill-tree {
        background: #374151;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
      }

      .skill-tree h3 {
        text-align: center;
        margin-bottom: 15px;
      }

      .skills-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 10px;
      }

      .skill-btn {
        background: #7c3aed;
        color: white;
        border: none;
        padding: 10px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all 0.3s;
        text-align: center;
      }

      .skill-btn:disabled {
        background: #6b7280;
        cursor: not-allowed;
      }

      .skill-btn:hover:not(:disabled) {
        background: #6d28d9;
      }

      .next-wave-btn {
        background: linear-gradient(45deg, #059669, #2563eb);
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.1em;
        margin-top: 20px;
        transition: all 0.3s;
      }

      .next-wave-btn:hover {
        transform: scale(1.05);
      }

      .achievements {
        background: #374151;
        padding: 20px;
        border-radius: 10px;
        margin-top: 20px;
      }

      .achievements h3 {
        text-align: center;
        margin-bottom: 15px;
      }

      .achievement-items {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        justify-content: center;
      }

      .achievement-item {
        background: #d97706;
        padding: 8px 15px;
        border-radius: 8px;
        font-size: 0.9em;
      }

      .game-over {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
      }

      .game-over-content {
        background: #374151;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        max-width: 500px;
      }

      .game-over h2 {
        color: #dc2626;
        margin-bottom: 20px;
      }

      .game-over-stats {
        margin-bottom: 30px;
      }

      .game-over-stats p {
        margin-bottom: 10px;
        font-size: 1.1em;
      }

      .play-again-btn {
        background: linear-gradient(45deg, #2563eb, #7c3aed);
        color: white;
        border: none;
        padding: 15px 40px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1.1em;
        transition: all 0.3s;
      }

      .play-again-btn:hover {
        transform: scale(1.05);
      }

      .hidden {
        display: none !important;
      }

      .prep-time {
        text-align: center;
        color: #fbbf24;
        margin-top: 20px;
      }

      .enemy {
        cursor: pointer;
        transition: opacity 0.2s;
      }

      .enemy:hover {
        opacity: 0.8;
      }

      .tutorial-highlight {
        box-shadow: 0 0 20px #fbbf24;
        border: 2px solid #fbbf24;
      }

      @media (max-width: 768px) {
        .stats-grid {
          grid-template-columns: repeat(3, 1fr);
        }

        .abilities {
          flex-direction: column;
          align-items: center;
        }

        .tower-buttons {
          flex-direction: column;
          align-items: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <!-- Menu Screen -->
      <div id="menu-screen" class="menu-screen">
        <h1>🏰 Enhanced Tower Defense</h1>

        <div class="menu-content">
          <div class="info-panel">
            <h2>📖 How to Play</h2>
            <p>👆 <strong>Click enemies</strong> to deal damage</p>
            <p>🏗️ <strong>Build towers</strong> to auto-attack</p>
            <p>⬆️ <strong>Upgrade towers</strong> for more damage</p>
            <p>🎯 <strong>Use abilities</strong> in tough situations</p>
            <p>🌟 <strong>Gain experience</strong> and upgrade skills</p>
            <p>🏆 <strong>Unlock achievements</strong> for bonuses</p>
          </div>

          <div class="info-panel">
            <h3>🗼 Tower Types</h3>
            <div class="tower-info">
              <span style="font-size: 1.2em">🔫</span>
              <span>Cannon - Balanced damage</span>
            </div>
            <div class="tower-info">
              <span style="font-size: 1.2em">⚡</span>
              <span>Laser - Fast firing</span>
            </div>
            <div class="tower-info">
              <span style="font-size: 1.2em">❄️</span>
              <span>Frost - Slows enemies</span>
            </div>
            <div class="tower-info">
              <span style="font-size: 1.2em">🚀</span>
              <span>Rocket - High damage</span>
            </div>
            <div class="tower-info">
              <span style="font-size: 1.2em">🎯</span>
              <span>Sniper - Extreme range</span>
            </div>
          </div>
        </div>

        <button class="start-btn" onclick="startGame()">🎮 Start Game</button>
      </div>

      <!-- Game Screen -->
      <div id="game-screen" class="game-screen">
        <h1>🏰 Enhanced Tower Defense</h1>

        <!-- Tutorial -->
        <div id="tutorial" class="tutorial hidden"></div>

        <!-- Effects -->
        <div id="effects"></div>

        <!-- Game Stats -->
        <div class="stats-grid">
          <div id="coins-stat" class="stat-item coins">💰 150</div>
          <div class="stat-item lives">
            ❤️ <span id="lives-display">20</span>
          </div>
          <div id="wave-stat" class="stat-item wave">
            🌊 W<span id="wave-display">1</span>
          </div>
          <div class="stat-item score">
            🏆 <span id="score-display">0</span>
          </div>
          <div class="stat-item level">
            ⭐ L<span id="level-display">1</span>
          </div>
          <div class="stat-item skill-points">
            🎯 <span id="skill-points-display">0</span>SP
          </div>
        </div>

        <!-- Experience Bar -->
        <div class="exp-bar">
          <div class="exp-bar-container">
            <div id="exp-bar-fill" class="exp-bar-fill" style="width: 0%"></div>
          </div>
          <div class="exp-text">
            XP: <span id="exp-display">0</span>/<span id="exp-required"
              >100</span
            >
          </div>
        </div>

        <!-- Kill Streak -->
        <div id="kill-streak" class="kill-streak hidden"></div>

        <!-- Wave Progress -->
        <div class="wave-progress">
          <div class="wave-progress-container">
            <div
              id="wave-progress-fill"
              class="wave-progress-fill"
              style="width: 0%"
            ></div>
          </div>
          <div class="wave-text" id="wave-text">
            Wave 1 starting in 3 seconds...
          </div>
        </div>

        <!-- Next Wave Preview -->
        <div id="next-wave-preview" class="next-wave-preview hidden">
          <div>Next Wave Preview:</div>
          <div id="enemy-preview" class="enemy-preview"></div>
        </div>

        <!-- Special Abilities -->
        <div id="abilities" class="abilities">
          <button class="ability-btn" onclick="useAbility('airstrike')">
            💣 <span id="airstrike-text">$50</span>
          </button>
          <button class="ability-btn" onclick="useAbility('freeze')">
            ❄️ <span id="freeze-text">$30</span>
          </button>
          <button class="ability-btn" onclick="useAbility('repair')">
            🔧 <span id="repair-text">$20</span>
          </button>
        </div>

        <!-- Game Area -->
        <svg id="game-area" class="game-area" width="800" height="400"></svg>

        <!-- Tower Selection -->
        <div id="tower-buttons" class="tower-buttons"></div>

        <!-- Tower Info Panel -->
        <div id="tower-info-panel" class="tower-info-panel hidden"></div>

        <!-- Skill Tree -->
        <div id="skill-tree" class="skill-tree hidden"></div>

        <!-- Next Wave Button -->
        <button
          id="next-wave-btn"
          class="next-wave-btn hidden"
          onclick="startNextWave()"
        >
          🌊 Start Wave 2
        </button>

        <!-- Preparation Time -->
        <div id="prep-time" class="prep-time hidden"></div>

        <!-- Achievements -->
        <div id="achievements" class="achievements hidden"></div>
      </div>

      <!-- Game Over Screen -->
      <div id="game-over" class="game-over">
        <div class="game-over-content">
          <h2>💀 Game Over!</h2>
          <div class="game-over-stats">
            <p>🌊 Wave Reached: <span id="final-wave">1</span></p>
            <p>🏆 Final Score: <span id="final-score">0</span></p>
            <p>⭐ Level: <span id="final-level">1</span></p>
            <p>🏅 Achievements: <span id="final-achievements">0</span></p>
          </div>
          <button class="play-again-btn" onclick="resetGame()">
            🔄 Play Again
          </button>
        </div>
      </div>
    </div>

    <script>
      // Game state
      let gameState = "menu";
      let coins = 150;
      let wave = 1;
      let lives = 20;
      let score = 0;
      let experience = 0;
      let level = 1;
      let skillPoints = 0;
      let enemies = [];
      let towers = [];
      let selectedTower = null;
      let placingTower = null;
      let tutorialStep = 0;
      let waveProgress = 0;
      let maxWaveEnemies = 5;
      let enemiesSpawned = 0;
      let isWaveActive = false;
      let mousePos = { x: 0, y: 0 };
      let killStreak = 0;
      let comboMultiplier = 1;
      let damageNumbers = [];
      let abilities = {
        airstrike: { cooldown: 0, maxCooldown: 15000, cost: 50 },
        freeze: { cooldown: 0, maxCooldown: 10000, cost: 30 },
        repair: { cooldown: 0, maxCooldown: 8000, cost: 20 },
      };
      let achievements = [];
      let skills = { damage: 0, range: 0, speed: 0, economy: 0, abilities: 0 };
      let powerUps = [];
      let effects = [];
      let nextWavePreview = null;
      let preparationTime = 0;

      // Game constants
      const GAME_WIDTH = 800;
      const GAME_HEIGHT = 400;
      let gameLoopRunning = false;
      let nextEnemyTime = 0;
      let enemyId = 0;
      let damageId = 0;
      let streakTimeout = null;

      // Tower types
      const TOWER_TYPES = {
        cannon: {
          cost: 30,
          damage: 2,
          range: 90,
          speed: 1800,
          emoji: "🔫",
          name: "Cannon",
        },
        laser: {
          cost: 75,
          damage: 1,
          range: 140,
          speed: 600,
          emoji: "⚡",
          name: "Laser",
        },
        rocket: {
          cost: 120,
          damage: 4,
          range: 80,
          speed: 3000,
          emoji: "🚀",
          name: "Rocket",
        },
        frost: {
          cost: 60,
          damage: 1,
          range: 100,
          speed: 1200,
          emoji: "❄️",
          name: "Frost",
          slow: 0.5,
        },
        sniper: {
          cost: 200,
          damage: 8,
          range: 200,
          speed: 4000,
          emoji: "🎯",
          name: "Sniper",
        },
      };

      // Enemy types
      const ENEMY_TYPES = {
        basic: { baseHp: 3, speed: 1.0, reward: 8, emoji: "🔴", name: "Basic" },
        fast: {
          baseHp: 2,
          speed: 2.2,
          reward: 12,
          emoji: "🟡",
          name: "Runner",
        },
        tank: { baseHp: 8, speed: 0.6, reward: 20, emoji: "🟣", name: "Tank" },
        flying: {
          baseHp: 4,
          speed: 1.5,
          reward: 15,
          emoji: "🔵",
          name: "Flying",
          flying: true,
        },
        boss: { baseHp: 25, speed: 0.4, reward: 50, emoji: "💀", name: "Boss" },
        swarm: { baseHp: 1, speed: 1.8, reward: 4, emoji: "🟢", name: "Swarm" },
      };

      // Achievement definitions
      const ACHIEVEMENT_DEFS = [
        {
          id: "first_kill",
          name: "First Blood",
          desc: "Kill your first enemy",
          reward: 20,
          icon: "🩸",
        },
        {
          id: "wave_5",
          name: "Survivor",
          desc: "Reach wave 5",
          reward: 50,
          icon: "🌊",
        },
        {
          id: "combo_10",
          name: "Combo Master",
          desc: "Get a 10x combo",
          reward: 100,
          icon: "🔥",
        },
        {
          id: "upgrade_10",
          name: "Engineer",
          desc: "Upgrade a tower to level 10",
          reward: 150,
          icon: "⚙️",
        },
        {
          id: "wave_10",
          name: "Veteran",
          desc: "Reach wave 10",
          reward: 200,
          icon: "🏆",
        },
        {
          id: "no_damage",
          name: "Flawless",
          desc: "Complete a wave without taking damage",
          reward: 100,
          icon: "💎",
        },
      ];

      // Skill tree definitions
      const SKILL_TREE = {
        damage: {
          name: "Damage",
          maxLevel: 10,
          cost: (level) => level * 2,
          bonus: 0.2,
        },
        range: {
          name: "Range",
          maxLevel: 10,
          cost: (level) => level * 2,
          bonus: 0.15,
        },
        speed: {
          name: "Attack Speed",
          maxLevel: 10,
          cost: (level) => level * 2,
          bonus: 0.15,
        },
        economy: {
          name: "Economy",
          maxLevel: 10,
          cost: (level) => level * 2,
          bonus: 0.25,
        },
        abilities: {
          name: "Abilities",
          maxLevel: 10,
          cost: (level) => level * 2,
          bonus: 0.2,
        },
      };

      // Tutorial steps
      const TUTORIAL_STEPS = [
        {
          text: "👋 Welcome! Click enemies to deal damage",
          highlight: "enemies",
        },
        {
          text: "💰 Earn coins and XP by defeating enemies",
          highlight: "coins",
        },
        { text: "🔫 Build towers to auto-attack enemies", highlight: "towers" },
        { text: "⬆️ Upgrade towers to increase damage", highlight: "upgrade" },
        {
          text: "🎯 Use special abilities to help in tough situations",
          highlight: "abilities",
        },
        { text: "🌊 Survive waves and unlock new content!", highlight: "wave" },
      ];

      // Utility functions
      function getExpForLevel(level) {
        return level * 100 + (level - 1) * 50;
      }

      function getScaledEnemy(type) {
        const base = ENEMY_TYPES[type];
        const waveMultiplier = 1 + (wave - 1) * 0.3;
        const hpMultiplier = 1 + (wave - 1) * 0.25;
        const speedMultiplier = 1 + (wave - 1) * 0.08;
        const rewardMultiplier = 1 + (wave - 1) * 0.2;

        return {
          ...base,
          hp: Math.floor(base.baseHp * hpMultiplier),
          maxHp: Math.floor(base.baseHp * hpMultiplier),
          speed: base.speed * speedMultiplier,
          reward: Math.floor(
            base.reward * rewardMultiplier * (1 + skills.economy * 0.25)
          ),
        };
      }

      function getEnemyPaths() {
        const paths = [
          {
            start: { x: -40, y: GAME_HEIGHT / 2 - 60 },
            points: [
              { x: GAME_WIDTH / 4, y: GAME_HEIGHT / 2 - 80 },
              { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2 - 60 },
              { x: (3 * GAME_WIDTH) / 4, y: GAME_HEIGHT / 2 - 40 },
              { x: GAME_WIDTH + 40, y: GAME_HEIGHT / 2 - 60 },
            ],
          },
        ];

        if (wave >= 3) {
          paths.push({
            start: { x: -40, y: GAME_HEIGHT / 2 },
            points: [
              { x: GAME_WIDTH / 4, y: GAME_HEIGHT / 2 - 20 },
              { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2 },
              { x: (3 * GAME_WIDTH) / 4, y: GAME_HEIGHT / 2 + 20 },
              { x: GAME_WIDTH + 40, y: GAME_HEIGHT / 2 },
            ],
          });
        }

        if (wave >= 6) {
          paths.push({
            start: { x: -40, y: GAME_HEIGHT / 2 + 60 },
            points: [
              { x: GAME_WIDTH / 4, y: GAME_HEIGHT / 2 + 80 },
              { x: GAME_WIDTH / 2, y: GAME_HEIGHT / 2 + 60 },
              { x: (3 * GAME_WIDTH) / 4, y: GAME_HEIGHT / 2 + 40 },
              { x: GAME_WIDTH + 40, y: GAME_HEIGHT / 2 + 60 },
            ],
          });
        }

        return paths;
      }

      function getAvailableTowers() {
        const towers = ["cannon"];
        if (wave >= 3) towers.push("laser");
        if (wave >= 5) towers.push("frost");
        if (wave >= 7) towers.push("rocket");
        if (wave >= 10) towers.push("sniper");
        return towers;
      }

      function generateWavePreview(waveNum) {
        const enemies = [];
        const waveSize = Math.min(5 + Math.floor(waveNum * 1.2), 20);

        for (let i = 0; i < waveSize; i++) {
          let type = "basic";
          const rand = Math.random();

          if (waveNum >= 2 && rand < 0.4) type = "fast";
          if (waveNum >= 3 && rand < 0.2) type = "tank";
          if (waveNum >= 4 && rand < 0.15) type = "flying";
          if (waveNum >= 6 && rand < 0.3) type = "swarm";
          if (waveNum >= 8 && rand < 0.1) type = "boss";

          enemies.push(type);
        }

        return enemies;
      }

      function getDistance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      }

      function getPositionAlongPath(path, progress) {
        if (!path || !path.points || path.points.length === 0) {
          return { x: 0, y: 0 };
        }

        const fullPath = [path.start, ...path.points];

        let totalLength = 0;
        const segmentLengths = [];

        for (let i = 0; i < fullPath.length - 1; i++) {
          const segmentLength = getDistance(
            fullPath[i].x,
            fullPath[i].y,
            fullPath[i + 1].x,
            fullPath[i + 1].y
          );
          segmentLengths.push(segmentLength);
          totalLength += segmentLength;
        }

        const targetDistance = progress * totalLength;
        let currentDistance = 0;

        for (let i = 0; i < segmentLengths.length; i++) {
          if (currentDistance + segmentLengths[i] >= targetDistance) {
            const segmentProgress =
              (targetDistance - currentDistance) / segmentLengths[i];
            const start = fullPath[i];
            const end = fullPath[i + 1];

            return {
              x: start.x + (end.x - start.x) * segmentProgress,
              y: start.y + (end.y - start.y) * segmentProgress,
            };
          }
          currentDistance += segmentLengths[i];
        }

        return fullPath[fullPath.length - 1];
      }

      function addDamageNumber(x, y, damage, color = "#ff4444") {
        const id = damageId++;
        const damageNum = {
          id,
          x,
          y,
          damage,
          color,
          opacity: 1,
          scale: 1,
          offsetY: 0,
        };

        damageNumbers.push(damageNum);

        setTimeout(() => {
          damageNumbers = damageNumbers.filter((d) => d.id !== id);
        }, 1000);
      }

      function addExperience(amount) {
        experience += amount;
        const requiredExp = getExpForLevel(level);

        if (experience >= requiredExp) {
          level++;
          skillPoints++;
          coins += 25;
          experience -= requiredExp;
          updateUI();
        }
      }

      function checkAchievements(type, data) {
        ACHIEVEMENT_DEFS.forEach((achievement) => {
          if (achievements.includes(achievement.id)) return;

          let unlock = false;

          switch (achievement.id) {
            case "first_kill":
              unlock = type === "kill";
              break;
            case "wave_5":
              unlock = type === "wave" && data >= 5;
              break;
            case "combo_10":
              unlock = type === "combo" && data >= 10;
              break;
            case "upgrade_10":
              unlock = type === "upgrade" && data >= 10;
              break;
            case "wave_10":
              unlock = type === "wave" && data >= 10;
              break;
            case "no_damage":
              unlock = type === "no_damage";
              break;
          }

          if (unlock) {
            achievements.push(achievement.id);
            coins += achievement.reward;
            showEffect(
              `🏆 ${achievement.name} - +${achievement.reward} coins!`
            );
          }
        });
      }

      function spawnEnemy() {
        if (enemiesSpawned >= maxWaveEnemies) return;

        const wavePreview = nextWavePreview || generateWavePreview(wave);
        const enemyIndex = enemiesSpawned % wavePreview.length;
        const type = wavePreview[enemyIndex];

        const scaledEnemy = getScaledEnemy(type);
        const availablePaths = getEnemyPaths();
        const selectedPath =
          availablePaths[Math.floor(Math.random() * availablePaths.length)];

        const enemy = {
          id: enemyId++,
          type,
          path: selectedPath,
          pathProgress: 0,
          x: selectedPath.start.x,
          y: selectedPath.start.y,
          slowEffect: 0,
          ...scaledEnemy,
        };

        enemies.push(enemy);
        enemiesSpawned++;
      }

      function handleEnemyClick(enemyId) {
        if (gameState !== "playing") return;

        const enemyIndex = enemies.findIndex((e) => e.id === enemyId);
        if (enemyIndex === -1) return;

        const enemy = enemies[enemyIndex];
        const clickDamage = 1 + Math.floor(skills.damage * 0.5);
        const newHp = enemy.hp - clickDamage;

        addDamageNumber(enemy.x, enemy.y - 20, clickDamage, "#ffff00");

        if (newHp <= 0) {
          const reward = Math.floor(enemy.reward * comboMultiplier);
          coins += reward;
          score += reward * 10;
          addExperience(5);

          // Update kill streak
          killStreak++;
          const newCombo = Math.min(Math.floor(killStreak / 3) + 1, 10);
          comboMultiplier = newCombo;

          checkAchievements("kill", killStreak);
          checkAchievements("combo", newCombo);

          // Reset streak timer
          if (streakTimeout) clearTimeout(streakTimeout);
          streakTimeout = setTimeout(() => {
            killStreak = 0;
            comboMultiplier = 1;
            updateUI();
          }, 3000);

          if (tutorialStep === 0) {
            tutorialStep = 1;
            updateTutorial();
          }

          enemies.splice(enemyIndex, 1);
        } else {
          enemies[enemyIndex].hp = newHp;
        }

        updateUI();
      }

      function useAbility(abilityType) {
        const ability = abilities[abilityType];
        if (ability.cooldown > 0 || coins < ability.cost) return;

        coins -= ability.cost;
        abilities[abilityType].cooldown = ability.maxCooldown;

        switch (abilityType) {
          case "airstrike":
            enemies.forEach((enemy) => {
              enemy.hp = Math.max(0, enemy.hp - (5 + skills.abilities * 2));
            });
            enemies = enemies.filter((enemy) => enemy.hp > 0);
            showEffect("💣 Airstrike launched!");
            break;

          case "freeze":
            enemies.forEach((enemy) => {
              enemy.slowEffect = 5000 + skills.abilities * 1000;
            });
            showEffect("❄️ Enemies frozen!");
            break;

          case "repair":
            lives = Math.min(20, lives + 3 + skills.abilities);
            showEffect("🔧 Base repaired!");
            break;
        }

        if (tutorialStep === 4) {
          tutorialStep = 5;
          updateTutorial();
        }

        updateUI();
      }

      function placeTower(x, y) {
        if (!placingTower || coins < TOWER_TYPES[placingTower].cost) return;

        const towerType = TOWER_TYPES[placingTower];
        const newTower = {
          id: Date.now(),
          type: placingTower,
          x: x - 20,
          y: y - 20,
          damage:
            towerType.damage +
            Math.floor(towerType.damage * skills.damage * 0.2),
          range:
            towerType.range + Math.floor(towerType.range * skills.range * 0.15),
          speed: Math.max(
            200,
            towerType.speed - Math.floor(towerType.speed * skills.speed * 0.15)
          ),
          lastShot: 0,
          level: 1,
          kills: 0,
          ...towerType,
        };

        towers.push(newTower);
        coins -= towerType.cost;
        placingTower = null;

        if (tutorialStep === 2) {
          tutorialStep = 3;
          updateTutorial();
        }

        updateUI();
        updateTowerButtons();
      }

      function upgradeTower(towerId) {
        const tower = towers.find((t) => t.id === towerId);
        if (!tower) return;

        const upgradeCost = 30 + (tower.level - 1) * 20;
        if (coins >= upgradeCost) {
          tower.damage += Math.floor(tower.damage * 0.6);
          tower.range += 12;
          tower.speed = Math.max(100, tower.speed - 100);
          tower.level++;

          coins -= upgradeCost;
          selectedTower = null;

          checkAchievements("upgrade", tower.level);

          if (tutorialStep === 3) {
            tutorialStep = 4;
            updateTutorial();
          }

          updateUI();
          updateTowerInfo();
        }
      }

      function upgradeSkill(skillType) {
        const skill = SKILL_TREE[skillType];
        const currentLevel = skills[skillType];

        if (
          currentLevel >= skill.maxLevel ||
          skillPoints < skill.cost(currentLevel + 1)
        )
          return;

        skillPoints -= skill.cost(currentLevel + 1);
        skills[skillType] = currentLevel + 1;

        updateUI();
        updateSkillTree();
      }

      function startNextWave() {
        wave++;
        enemiesSpawned = 0;
        maxWaveEnemies = Math.min(5 + Math.floor(wave * 1.2), 20);
        isWaveActive = true;
        coins += 15 + wave * 5;
        preparationTime = 0;

        nextWavePreview = generateWavePreview(wave + 1);

        checkAchievements("wave", wave);

        if (tutorialStep === 5) {
          tutorialStep = -1;
          updateTutorial();
        }

        updateUI();
        updateWavePreview();
      }

      function showEffect(text) {
        const effectDiv = document.createElement("div");
        effectDiv.className = "effects";
        effectDiv.textContent = text;
        document.getElementById("effects").appendChild(effectDiv);

        setTimeout(() => {
          effectDiv.remove();
        }, 3000);
      }

      function updateUI() {
        document.getElementById("coins-stat").textContent = `💰 ${coins}`;
        document.getElementById("lives-display").textContent = lives;
        document.getElementById("wave-display").textContent = wave;
        document.getElementById("score-display").textContent = score;
        document.getElementById("level-display").textContent = level;
        document.getElementById("skill-points-display").textContent =
          skillPoints;

        const expRequired = getExpForLevel(level);
        document.getElementById("exp-bar-fill").style.width = `${
          (experience / expRequired) * 100
        }%`;
        document.getElementById("exp-display").textContent = experience;
        document.getElementById("exp-required").textContent = expRequired;

        if (killStreak > 0) {
          document.getElementById(
            "kill-streak"
          ).textContent = `🔥 ${killStreak} Streak • ${comboMultiplier}x Combo`;
          document.getElementById("kill-streak").classList.remove("hidden");
        } else {
          document.getElementById("kill-streak").classList.add("hidden");
        }

        document.getElementById(
          "wave-progress-fill"
        ).style.width = `${waveProgress}%`;

        if (isWaveActive) {
          document.getElementById(
            "wave-text"
          ).textContent = `${enemiesSpawned}/${maxWaveEnemies} enemies spawned`;
        } else if (enemies.length > 0) {
          document.getElementById(
            "wave-text"
          ).textContent = `${enemies.length} enemies remaining`;
        } else if (preparationTime > 0) {
          document.getElementById(
            "wave-text"
          ).textContent = `Prep time: ${Math.ceil(preparationTime / 1000)}s`;
        } else {
          document.getElementById("wave-text").textContent = "Wave complete!";
        }

        // Update ability buttons
        Object.keys(abilities).forEach((key) => {
          const ability = abilities[key];
          const button = document.querySelector(
            `[onclick="useAbility('${key}')"]`
          );
          const textSpan = document.getElementById(`${key}-text`);

          if (ability.cooldown > 0) {
            textSpan.textContent = Math.ceil(ability.cooldown / 1000);
            button.disabled = true;
          } else if (coins < ability.cost) {
            textSpan.textContent = `$${ability.cost}`;
            button.disabled = true;
          } else {
            textSpan.textContent = `$${ability.cost}`;
            button.disabled = false;
          }
        });

        // Update skill tree
        if (skillPoints > 0) {
          document.getElementById("skill-tree").classList.remove("hidden");
          updateSkillTree();
        } else {
          document.getElementById("skill-tree").classList.add("hidden");
        }

        // Update achievements
        if (achievements.length > 0) {
          document.getElementById("achievements").classList.remove("hidden");
          updateAchievements();
        }

        // Update next wave button
        if (
          !isWaveActive &&
          enemies.length === 0 &&
          enemiesSpawned >= maxWaveEnemies &&
          preparationTime === 0
        ) {
          document.getElementById("next-wave-btn").classList.remove("hidden");
          document.getElementById(
            "next-wave-btn"
          ).textContent = `🌊 Start Wave ${wave + 1}`;
        } else {
          document.getElementById("next-wave-btn").classList.add("hidden");
        }

        // Update preparation time
        if (preparationTime > 0) {
          document.getElementById(
            "prep-time"
          ).textContent = `Prep time: ${Math.ceil(preparationTime / 1000)}s`;
          document.getElementById("prep-time").classList.remove("hidden");
        } else {
          document.getElementById("prep-time").classList.add("hidden");
        }

        // Check game over
        if (lives <= 0 && gameState === "playing") {
          gameState = "gameOver";
          gameLoopRunning = false;
          showGameOver();
        }
      }

      function updateTutorial() {
        const tutorialDiv = document.getElementById("tutorial");
        if (tutorialStep >= 0 && tutorialStep < TUTORIAL_STEPS.length) {
          tutorialDiv.textContent = TUTORIAL_STEPS[tutorialStep].text;
          tutorialDiv.classList.remove("hidden");
        } else {
          tutorialDiv.classList.add("hidden");
        }
      }

      function updateTowerButtons() {
        const container = document.getElementById("tower-buttons");
        container.innerHTML = "";

        getAvailableTowers().forEach((towerType) => {
          const tower = TOWER_TYPES[towerType];
          const canAfford = coins >= tower.cost;

          const button = document.createElement("button");
          button.className = `tower-btn ${
            placingTower === towerType ? "selected" : ""
          }`;
          button.disabled = !canAfford;
          button.innerHTML = `<span style="font-size: 1.2em;">${tower.emoji}</span> $${tower.cost}`;
          button.onclick = () => {
            placingTower = towerType;
            updateTowerButtons();
          };

          container.appendChild(button);
        });
      }

      function updateTowerInfo() {
        const panel = document.getElementById("tower-info-panel");

        if (selectedTower) {
          panel.innerHTML = `
                    <h3>${TOWER_TYPES[selectedTower.type].emoji} ${
            TOWER_TYPES[selectedTower.type].name
          } (Level ${selectedTower.level})</h3>
                    <div class="tower-stats">
                        <span>💥 ${selectedTower.damage} DMG</span>
                        <span>🎯 ${selectedTower.range} Range</span>
                        <span>🔄 ${selectedTower.kills} Kills</span>
                    </div>
                    <button class="upgrade-btn" onclick="upgradeTower(${
                      selectedTower.id
                    })" ${
            coins < 30 + (selectedTower.level - 1) * 20 ? "disabled" : ""
          }>
                        ⬆️ Upgrade ($${30 + (selectedTower.level - 1) * 20})
                    </button>
                `;
          panel.classList.remove("hidden");
        } else {
          panel.classList.add("hidden");
        }
      }

      function updateSkillTree() {
        const skillTree = document.getElementById("skill-tree");
        skillTree.innerHTML = `
                <h3>🌟 Skill Tree (${skillPoints} points)</h3>
                <div class="skills-grid">
                    ${Object.entries(SKILL_TREE)
                      .map(
                        ([key, skill]) => `
                        <button class="skill-btn" onclick="upgradeSkill('${key}')" 
                                ${
                                  skills[key] >= skill.maxLevel ||
                                  skillPoints < skill.cost(skills[key] + 1)
                                    ? "disabled"
                                    : ""
                                }>
                            <div>${skill.name}</div>
                            <div style="font-size: 0.8em;">${skills[key]}/${
                          skill.maxLevel
                        }</div>
                            <div style="font-size: 0.8em;">(${skill.cost(
                              skills[key] + 1
                            )})</div>
                        </button>
                    `
                      )
                      .join("")}
                </div>
            `;
      }

      function updateAchievements() {
        const achievementsDiv = document.getElementById("achievements");
        achievementsDiv.innerHTML = `
                <h3>🏆 Achievements</h3>
                <div class="achievement-items">
                    ${achievements
                      .map((achId) => {
                        const achievement = ACHIEVEMENT_DEFS.find(
                          (a) => a.id === achId
                        );
                        return achievement
                          ? `<div class="achievement-item">${achievement.icon} ${achievement.name}</div>`
                          : "";
                      })
                      .join("")}
                </div>
            `;
      }

      function updateWavePreview() {
        const preview = document.getElementById("next-wave-preview");
        const enemyPreview = document.getElementById("enemy-preview");

        if (nextWavePreview && !isWaveActive) {
          enemyPreview.innerHTML = nextWavePreview
            .slice(0, 10)
            .map(
              (type) =>
                `<span style="font-size: 1.2em;">${ENEMY_TYPES[type].emoji}</span>`
            )
            .join("");

          if (nextWavePreview.length > 10) {
            enemyPreview.innerHTML += `<span style="color: #9ca3af;">+${
              nextWavePreview.length - 10
            }</span>`;
          }

          preview.classList.remove("hidden");
        } else {
          preview.classList.add("hidden");
        }
      }

      function showGameOver() {
        document.getElementById("final-wave").textContent = wave;
        document.getElementById("final-score").textContent = score;
        document.getElementById("final-level").textContent = level;
        document.getElementById("final-achievements").textContent =
          achievements.length;
        document.getElementById("game-over").style.display = "flex";
      }

      function startGame() {
        gameState = "playing";
        tutorialStep = 0;
        nextWavePreview = generateWavePreview(1);

        document.getElementById("menu-screen").style.display = "none";
        document.getElementById("game-screen").style.display = "flex";

        updateUI();
        updateTutorial();
        updateTowerButtons();
        updateWavePreview();

        // Auto-start first wave after 3 seconds
        setTimeout(() => {
          isWaveActive = true;
          enemiesSpawned = 0;
          maxWaveEnemies = 5;
          nextEnemyTime = 0;
          updateUI();
          startGameLoop();
        }, 3000);
      }

      function resetGame() {
        gameState = "menu";
        coins = 150;
        wave = 1;
        lives = 20;
        score = 0;
        experience = 0;
        level = 1;
        skillPoints = 0;
        enemies = [];
        towers = [];
        selectedTower = null;
        placingTower = null;
        tutorialStep = 0;
        waveProgress = 0;
        maxWaveEnemies = 5;
        enemiesSpawned = 0;
        isWaveActive = false;
        killStreak = 0;
        comboMultiplier = 1;
        damageNumbers = [];
        achievements = [];
        skills = { damage: 0, range: 0, speed: 0, economy: 0, abilities: 0 };
        powerUps = [];
        effects = [];
        nextWavePreview = null;
        preparationTime = 0;
        mousePos = { x: 0, y: 0 };
        abilities = {
          airstrike: { cooldown: 0, maxCooldown: 15000, cost: 50 },
          freeze: { cooldown: 0, maxCooldown: 10000, cost: 30 },
          repair: { cooldown: 0, maxCooldown: 8000, cost: 20 },
        };
        nextEnemyTime = 0;
        enemyId = 0;
        damageId = 0;
        gameLoopRunning = false;

        if (streakTimeout) {
          clearTimeout(streakTimeout);
          streakTimeout = null;
        }

        document.getElementById("menu-screen").style.display = "flex";
        document.getElementById("game-screen").style.display = "none";
        document.getElementById("game-over").style.display = "none";
        document.getElementById("effects").innerHTML = "";

        // Clear SVG
        document.getElementById("game-area").innerHTML = "";
      }

      function startGameLoop() {
        if (gameLoopRunning) return;
        gameLoopRunning = true;

        function gameLoop() {
          if (!gameLoopRunning) return;

          const now = Date.now();

          // Update ability cooldowns
          Object.keys(abilities).forEach((key) => {
            if (abilities[key].cooldown > 0) {
              abilities[key].cooldown = Math.max(
                0,
                abilities[key].cooldown - 16
              );
            }
          });

          // Update damage numbers
          damageNumbers.forEach((dmg) => {
            dmg.offsetY -= 2;
            dmg.opacity = Math.max(0, dmg.opacity - 0.02);
            dmg.scale = Math.min(1.5, dmg.scale + 0.01);
          });

          // Spawn enemies during wave
          if (
            isWaveActive &&
            now > nextEnemyTime &&
            enemiesSpawned < maxWaveEnemies
          ) {
            spawnEnemy();
            const spawnDelay = Math.max(2000 - wave * 60, 800);
            nextEnemyTime = now + spawnDelay;
          }

          // Update wave progress
          waveProgress = (enemiesSpawned / maxWaveEnemies) * 100;

          // Move enemies
          enemies.forEach((enemy) => {
            if (!enemy.path) return;

            const slowMultiplier = enemy.slowEffect > 0 ? 0.3 : 1;
            enemy.slowEffect = Math.max(0, enemy.slowEffect - 16);

            enemy.pathProgress += enemy.speed * slowMultiplier * 0.0015;
            const newPosition = getPositionAlongPath(
              enemy.path,
              enemy.pathProgress
            );
            enemy.x = newPosition.x;
            enemy.y = newPosition.y;
          });

          // Check enemies that reached the end
          const reachedEnd = enemies.filter((e) => e.pathProgress >= 1);
          if (reachedEnd.length > 0) {
            lives = Math.max(0, lives - reachedEnd.length);
          }

          enemies = enemies.filter((e) => e.pathProgress < 1);

          // Check if wave is complete
          if (
            isWaveActive &&
            enemiesSpawned >= maxWaveEnemies &&
            enemies.length === 0
          ) {
            isWaveActive = false;
            preparationTime = 8000;
          }

          // Tower shooting
          towers.forEach((tower) => {
            if (now - tower.lastShot > tower.speed) {
              const target = enemies
                .filter((enemy) => {
                  const dist = getDistance(
                    enemy.x,
                    enemy.y,
                    tower.x + 20,
                    tower.y + 20
                  );
                  return dist <= tower.range;
                })
                .sort((a, b) => b.pathProgress - a.pathProgress)[0];

              if (target) {
                tower.lastShot = now;
                const damage =
                  tower.damage + Math.floor(tower.damage * skills.damage * 0.2);
                target.hp -= damage;

                addDamageNumber(target.x, target.y - 20, damage, "#ff6666");

                if (tower.type === "frost") {
                  target.slowEffect = 2000;
                }

                if (target.hp <= 0) {
                  const reward = Math.floor(
                    target.reward * (1 + skills.economy * 0.25)
                  );
                  coins += reward;
                  score += reward * 10;
                  addExperience(3);
                  tower.kills++;

                  const enemyIndex = enemies.indexOf(target);
                  if (enemyIndex !== -1) {
                    enemies.splice(enemyIndex, 1);
                  }
                }
              }
            }
          });

          // Update preparation time
          if (preparationTime > 0) {
            preparationTime = Math.max(0, preparationTime - 16);
          }

          updateUI();
          renderGame();
          requestAnimationFrame(gameLoop);
        }

        gameLoop();
      }

      function renderGame() {
        const svg = document.getElementById("game-area");
        svg.innerHTML = "";

        // Draw paths
        getEnemyPaths().forEach((path, index) => {
          if (!path || !path.points || !path.start) return;

          const pathElement = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          pathElement.setAttribute(
            "d",
            `M ${path.start.x} ${path.start.y} ${path.points
              .map((p) => `L ${p.x} ${p.y}`)
              .join(" ")}`
          );
          pathElement.setAttribute("stroke", "#8b5a2b");
          pathElement.setAttribute("stroke-width", "40");
          pathElement.setAttribute("fill", "none");
          pathElement.setAttribute("opacity", "0.8");
          svg.appendChild(pathElement);
        });

        // Draw tower placement preview
        if (placingTower && TOWER_TYPES[placingTower]) {
          const rangeCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          rangeCircle.setAttribute("cx", mousePos.x);
          rangeCircle.setAttribute("cy", mousePos.y);
          rangeCircle.setAttribute("r", TOWER_TYPES[placingTower].range);
          rangeCircle.setAttribute("fill", "rgba(59, 130, 246, 0.2)");
          rangeCircle.setAttribute("stroke", "rgba(59, 130, 246, 0.5)");
          rangeCircle.setAttribute("stroke-width", "2");
          rangeCircle.setAttribute("opacity", "0.6");
          svg.appendChild(rangeCircle);

          const previewRect = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect"
          );
          previewRect.setAttribute("x", mousePos.x - 20);
          previewRect.setAttribute("y", mousePos.y - 20);
          previewRect.setAttribute("width", "40");
          previewRect.setAttribute("height", "40");
          previewRect.setAttribute("fill", "#374151");
          previewRect.setAttribute("stroke", "#6b7280");
          previewRect.setAttribute("stroke-width", "2");
          previewRect.setAttribute("rx", "6");
          previewRect.setAttribute("opacity", "0.6");
          svg.appendChild(previewRect);

          const previewText = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          previewText.setAttribute("x", mousePos.x);
          previewText.setAttribute("y", mousePos.y + 6);
          previewText.setAttribute("text-anchor", "middle");
          previewText.setAttribute("font-size", "16");
          previewText.setAttribute("fill", "white");
          previewText.setAttribute("opacity", "0.6");
          previewText.textContent = TOWER_TYPES[placingTower].emoji;
          svg.appendChild(previewText);
        }

        // Draw enemies
        enemies.forEach((enemy) => {
          const enemyGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );
          enemyGroup.className = "enemy";

          const enemyCircle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
          );
          enemyCircle.setAttribute("cx", enemy.x);
          enemyCircle.setAttribute("cy", enemy.y);
          enemyCircle.setAttribute("r", "20");
          enemyCircle.setAttribute(
            "fill",
            enemy.slowEffect > 0 ? "#3b82f6" : "#1f2937"
          );
          enemyCircle.setAttribute("stroke", "#fff");
          enemyCircle.setAttribute("stroke-width", "2");
          enemyCircle.style.cursor = "pointer";
          enemyCircle.onclick = () => handleEnemyClick(enemy.id);
          enemyGroup.appendChild(enemyCircle);

          const enemyText = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          enemyText.setAttribute("x", enemy.x);
          enemyText.setAttribute("y", enemy.y + 6);
          enemyText.setAttribute("text-anchor", "middle");
          enemyText.setAttribute("font-size", "20");
          enemyText.style.pointerEvents = "none";
          enemyText.style.userSelect = "none";
          enemyText.textContent = ENEMY_TYPES[enemy.type].emoji;
          enemyGroup.appendChild(enemyText);

          // Health bar
          const healthBarBg = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect"
          );
          healthBarBg.setAttribute("x", enemy.x - 18);
          healthBarBg.setAttribute("y", enemy.y - 35);
          healthBarBg.setAttribute("width", "36");
          healthBarBg.setAttribute("height", "6");
          healthBarBg.setAttribute("fill", "#374151");
          healthBarBg.setAttribute("rx", "3");
          enemyGroup.appendChild(healthBarBg);

          const healthBar = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect"
          );
          healthBar.setAttribute("x", enemy.x - 18);
          healthBar.setAttribute("y", enemy.y - 35);
          healthBar.setAttribute("width", 36 * (enemy.hp / enemy.maxHp));
          healthBar.setAttribute("height", "6");
          healthBar.setAttribute("fill", "#10b981");
          healthBar.setAttribute("rx", "3");
          enemyGroup.appendChild(healthBar);

          svg.appendChild(enemyGroup);
        });

        // Draw towers
        towers.forEach((tower) => {
          const towerGroup = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "g"
          );

          // Show range for selected tower
          if (selectedTower && selectedTower.id === tower.id) {
            const rangeCircle = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "circle"
            );
            rangeCircle.setAttribute("cx", tower.x + 20);
            rangeCircle.setAttribute("cy", tower.y + 20);
            rangeCircle.setAttribute("r", tower.range);
            rangeCircle.setAttribute("fill", "rgba(59, 130, 246, 0.1)");
            rangeCircle.setAttribute("stroke", "rgba(59, 130, 246, 0.3)");
            rangeCircle.setAttribute("stroke-width", "2");
            towerGroup.appendChild(rangeCircle);
          }

          const towerRect = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "rect"
          );
          towerRect.setAttribute("x", tower.x);
          towerRect.setAttribute("y", tower.y);
          towerRect.setAttribute("width", "40");
          towerRect.setAttribute("height", "40");
          towerRect.setAttribute("fill", "#374151");
          towerRect.setAttribute("stroke", "#6b7280");
          towerRect.setAttribute("stroke-width", "2");
          towerRect.setAttribute("rx", "6");
          towerRect.style.cursor = "pointer";
          towerRect.onclick = () => {
            selectedTower = tower;
            placingTower = null;
            updateTowerInfo();
            updateTowerButtons();
          };
          towerGroup.appendChild(towerRect);

          const towerEmoji = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          towerEmoji.setAttribute("x", tower.x + 20);
          towerEmoji.setAttribute("y", tower.y + 18);
          towerEmoji.setAttribute("text-anchor", "middle");
          towerEmoji.setAttribute("font-size", "16");
          towerEmoji.style.pointerEvents = "none";
          towerEmoji.style.userSelect = "none";
          towerEmoji.textContent = TOWER_TYPES[tower.type].emoji;
          towerGroup.appendChild(towerEmoji);

          const towerLevel = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          towerLevel.setAttribute("x", tower.x + 20);
          towerLevel.setAttribute("y", tower.y + 32);
          towerLevel.setAttribute("text-anchor", "middle");
          towerLevel.setAttribute("font-size", "10");
          towerLevel.setAttribute("fill", "#fbbf24");
          towerLevel.setAttribute("font-weight", "bold");
          towerLevel.style.pointerEvents = "none";
          towerLevel.style.userSelect = "none";
          towerLevel.textContent = tower.level;
          towerGroup.appendChild(towerLevel);

          svg.appendChild(towerGroup);
        });

        // Draw damage numbers
        damageNumbers.forEach((dmg) => {
          const damageText = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          damageText.setAttribute("x", dmg.x);
          damageText.setAttribute("y", dmg.y + dmg.offsetY);
          damageText.setAttribute("text-anchor", "middle");
          damageText.setAttribute("font-size", "14");
          damageText.setAttribute("fill", dmg.color);
          damageText.setAttribute("font-weight", "bold");
          damageText.setAttribute("opacity", dmg.opacity);
          damageText.setAttribute("transform", `scale(${dmg.scale})`);
          damageText.style.pointerEvents = "none";
          damageText.style.userSelect = "none";
          damageText.textContent = `-${dmg.damage}`;
          svg.appendChild(damageText);
        });
      }

      // Event listeners
      document.getElementById("game-area").addEventListener("click", (e) => {
        if (placingTower) {
          const rect = e.target.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          placeTower(x, y);
        } else {
          selectedTower = null;
          updateTowerInfo();
        }
      });

      document
        .getElementById("game-area")
        .addEventListener("mousemove", (e) => {
          if (placingTower) {
            const rect = e.target.getBoundingClientRect();
            mousePos.x = e.clientX - rect.left;
            mousePos.y = e.clientY - rect.top;

            if (placingTower) {
              document.getElementById("game-area").classList.add("placing");
            } else {
              document.getElementById("game-area").classList.remove("placing");
            }
          }
        });

      // Initialize game
      document.addEventListener("DOMContentLoaded", () => {
        updateUI();
        updateTowerButtons();

        // Show first wave countdown for tutorial
        if (wave === 1 && !isWaveActive && enemies.length === 0) {
          document.getElementById("wave-text").textContent =
            "Wave 1 starting in 3 seconds...";
        }
      });
    </script>
  </body>
</html>
